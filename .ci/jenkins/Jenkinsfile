@Library('jenkins-pipeline-shared-libraries')_

changeAuthor = env.ghprbAuthorRepoGitUrl ? util.getGroup(env.ghprbAuthorRepoGitUrl) : (env.ghprbPullAuthorLogin ?: CHANGE_AUTHOR)
changeBranch = env.ghprbSourceBranch ?: CHANGE_BRANCH
changeTarget = env.ghprbTargetBranch ?: CHANGE_TARGET

BUILD_FAILED_IMAGES = []

pipeline {
    agent {
        label 'kie-rhel8 && docker && kie-mem24g && !built-in'
    }
    tools {
        maven env.BUILD_MAVEN_TOOL
        jdk env.BUILD_JDK_TOOL
    }
    options {
        timeout(time: 120, unit: 'MINUTES')
    }
    environment {
        CI = true

        // Linked to node label
        // Use docker due to multiplatform build
        CONTAINER_ENGINE='docker'
        CONTAINER_ENGINE_TLS_OPTIONS=''

        BUILD_IMAGE_PLATFORMS = 'linux/amd64,linux/arm64'
    }
    stages {
        stage('Initialization') {
            steps {
                script {
                    clean()

                    githubscm.checkoutIfExists('kogito-images', changeAuthor, changeBranch, 'kiegroup', changeTarget, true)

                    if (isProdCI()) {
                        // Prod fix to be able to build the image as a community one
                        sh "echo '' > content_sets.yaml"
                    }

                    prepareForDockerMultiplatformBuild()
                    startLocalRegistry()
                }
            }
        }
        stage('Validate CeKit Image and Modules descriptors') {
            steps {
                script {
                    sh '''
                        curl -Ls https://github.com/kiegroup/kie-cloud-tools/releases/download/v1.3.6/cekit-image-validator-runner.tgz --output cekit-image-validator-runner.tgz
                        tar -xzvf cekit-image-validator-runner.tgz
                        chmod +x cekit-image-validator-runner
                    '''
                    sh './cekit-image-validator-runner modules/'
                    getImages().each { image -> sh "./cekit-image-validator-runner ${image}-image.yaml" }
                }
            }
        }
        stage('Prepare environment') {
            steps {
                script {
                    // Set the mirror url only if exist
                    if (env.MAVEN_MIRROR_REPOSITORY) {
                        env.MAVEN_MIRROR_URL = env.MAVEN_MIRROR_REPOSITORY
                        
                        // Ignore self-signed certificates if MAVEN_MIRROR_URL is defined
                        runPythonCommand("python3 scripts/update-repository.py --build-maven-mirror-url ${MAVEN_MIRROR_URL} --ignore-self-signed-cert")
                    }
                }
            }
        }
        // Commented as we cannot fully rely on Quarkus platform
        // Should be uncommmented once https://issues.redhat.com/browse/KOGITO-9120 is implemented
        // stage('Setup Quarkus platform') {
        //     steps {
        //         script {
        //             String kogitoVersion = sh(returnStdout: true, script: 'make display-kogito-version')
        //             String quarkusPlatformVersion = "kogito-${kogitoVersion}"

        //             // Setup quarkus platform repo configuration
        //             runPythonCommand("python3 scripts/update-repository.py --repo-url ${QUARKUS_PLATFORM_NEXUS_URL} --ignore-self-signed-cert --quarkus-platform-version ${quarkusPlatformVersion}")
        //         }
        //     }
        // }
        stage('Prepare offline kogito-examples') {
            steps {
                script {
                    runPythonCommand('make clone-repos')
                }
            }
        }
        stage('Build & Test Images') {
            steps {
                script {
                    parallelStages = [:]
                    getImages().each { image ->
                        initWorkspace(image)
                        String workspacePath = getWorkspacePath(image)
                        parallelStages["Build&Test ${image}"] = {
                            stage("Build/Test ${image}") {
                                dir(workspacePath) {
                                    try {
                                        buildImage(image)
                                    } catch (err) {
                                        registerBuildFailedImage(image)
                                        util.archiveConsoleLog(image, 400)
                                        throw err
                                    }
                                    try {
                                        testImage(image)
                                    } catch (err) {
                                        echo "Testing error(s) for image ${image}"
                                    } finally {
                                        junit testResults: 'target/**/*.xml', allowEmptyResults: true
                                        archiveArtifacts artifacts: 'target/**/*.xml', allowEmptyArchive: true
                                    }
                                }
                            }
                        }
                    }
                    parallel parallelStages
                }
            }
            post {
                always {
                    script {
                        cleanWorkspaces()
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                clean()
            }
        }
        unsuccessful {
            script {
                def additionalInfo = ''
                if (getBuildFailedImages()) {
                    additionalInfo += 'Build failures on those images:\n'
                    getBuildFailedImages().each {
                        additionalInfo += "- ${it}\n"
                    }
                }
                pullrequest.postComment(util.getMarkdownTestSummary('PR', additionalInfo, "${BUILD_URL}", 'GITHUB'))
            }
        }
    }
}

void clean() {
    cleanWorkspaces()
    util.cleanNode(env.CONTAINER_ENGINE)
    
    cleanDockerMultiplatformBuild()
    cleanLocalRegistry()

    // Clean Cekit cache, in case we reuse an old node
    sh "rm -rf \$HOME/.cekit/cache"
}

void launchParallelForEachImage(stageNamePrefix, executeOnImage) {
    parallelStages = [:]
    getImages().each { image ->
        parallelStages["${stageNamePrefix} ${image}"] = {
            dir(getWorkspacePath(image)) {
                executeOnImage(image)
            }
        }
    }
    parallel parallelStages
}

void buildImage(String imageName) {
    // Generate the Dockerfile
    runPythonCommand("make build-image ${getMakeBuildImageArgs()} image_name=${imageName} ignore_test=true ignore_tag=true build_options='--dry-run'")

    // Build multiplatform from generated Dockerfile
    dir('target/image') {
        dockerBuildMultiPlatform(getTempBuiltImageTag(imageName))
    }
}

void testImage(String imageName) {
    String testImageTag = "quay.io/kiegroup/${imageName}:${getImageVersion()}"
    String tempBuiltImageTag = getTempBuiltImageTag(imageName)
    // Pull and tag to test image
    sh """
        docker pull ${tempBuiltImageTag}
        docker tag ${tempBuiltImageTag} ${testImageTag}
    """
    runPythonCommand("make build-image ${getMakeBuildImageArgs()} image_name=${imageName} ignore_build=true ignore_test_prepare=true ignore_tag=${isProdCI()}")
}

String getMakeBuildImageArgs() {
    List args = [ "cekit_option='--work-dir .'" ]
    args.add("KOGITO_APPS_TARGET_BRANCH=${changeTarget}")
    args.add("BUILD_ENGINE=${CONTAINER_ENGINE}")
    if (env.CONTAINER_ENGINE_TLS_OPTIONS) {
        args.add("BUILD_ENGINE_TLS_OPTIONS=${CONTAINER_ENGINE_TLS_OPTIONS}")   
    }
    return args.join(' ')
}

void registerBuildFailedImage(String imageName) {
    lock("${BUILD_URL} build failed") {
        BUILD_FAILED_IMAGES.add(imageName)
    }
}

List getBuildFailedImages() {
    return BUILD_FAILED_IMAGES
}

void initWorkspace(String image) {
    sh "mkdir -p ${getWorkspacePath(image)}"
    sh "rsync -av --progress . ${getWorkspacePath(image)} --exclude workspaces"
}

void cleanWorkspaces() {
    sh "rm -rf ${getWorkspacesPath()}"
}

String getWorkspacesPath() {
    return "${WORKSPACE}/workspaces"
}

String getWorkspacePath(String image) {
    return "${getWorkspacesPath()}/${image}"
}

String[] getImages() {
    String listCmd = 'make list'
    if (isProdCI()) {
        listCmd += ' arg=--prod'
    }
    return runPythonCommand("${listCmd} | tr '\\n' ','", true).trim().split(',')
}

String getImageVersion() {
    return runPythonCommand('make display-image-version', true).trim()
}

boolean isProdCI() {
    return env.PROD_CI ? env.PROD_CI.toBoolean() : false
}

String getTempBuiltImageTag(String imageName) {
    return "localhost:5000/${imageName}:${githubscm.getCommitHash()}"
}

void runPythonCommand(String cmd, boolean stdout = false) {
    return sh(returnStdout: stdout, script: """
source ~/virtenvs/cekit/bin/activate 
${cmd}
""")
}

void prepareForDockerMultiplatformBuild(boolean debug = false) {
    // For multiplatform build
    sh 'docker run --rm --privileged --name binfmt docker.io/tonistiigi/binfmt --install all'
    
    // Debug purpose
    if (debug) {
        sh 'docker context ls'
        sh 'docker buildx ls'
        sh 'docker ps'
    }
    
    writeFile(file: 'buildkitd.toml', text: '''
debug = true
[registry."docker.io"]
mirrors = ["mirror.gcr.io"]
[registry."localhost:5000"]
http = true
        ''')
    
    sh 'docker buildx rm mybuilder || true'
    sh 'docker buildx create --name mybuilder --driver docker-container --driver-opt network=host --bootstrap --config ${WORKSPACE}/buildkitd.toml'
    sh 'docker buildx use mybuilder'
    
    if (debug) {
        sh 'docker buildx inspect'
        sh 'docker buildx ls'
        sh 'docker ps'
    }
}

void dockerBuildMultiPlatform(String buildImageTag) {
    // Build image locally in tgz file
    sh """
        docker buildx build --push --sbom=false --provenance=false --platform ${BUILD_IMAGE_PLATFORMS} -t ${buildImageTag} .
        docker buildx imagetools inspect ${buildImageTag}
    """
}

void startLocalRegistry() {
    sh 'docker run -d -p 5000:5000 --restart=always --name registry --name registry registry:2'
}

void cleanLocalRegistry() {
    sh 'docker kill registry || true'
}

void cleanDockerMultiplatformBuild() {
    sh 'docker buildx rm mybuilder || true'
    sh 'docker kill binfmt || true'
}
